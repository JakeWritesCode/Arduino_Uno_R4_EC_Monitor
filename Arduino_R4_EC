// This script tries to port (in spirit at least) the wonderfule repo at
// https://github.com/wvmarle/Arduino_ECSensor to the Arduino Uno R4.
// The new arduino os based on a 32bit ARM arch ather than the 8bit ATMega.

// We've sacrificed some speed of execution here in favour of readability.
// For example, we're using digitalWrite rather than dealing with the registers directly.
// My theory is that it will be a reasonably consistent delay which we can calibrate
// by measuring known samples and offsetting with some linear interpolation.

// Let's see if i'm right.

#include <cmath>

// Pin definitions
#define CAPPOS_PIN 2
#define CAPNEG_PIN 4
#define EC_PIN 7

// Config
#define CHARGE_DELAY 40     // Time taken to charge the capacitor
#define DISCHARGE_DELAY 100  // A delay to allow the cap to fully discharge, prevent pin damage
#define EC_TIMEOUT 2000     // Timeout waiting for polarity to flip, something is broken.
#define CLOCKSPEED 48       // 48mhz
#define OVERSAMPLING_RATE 10 // Number of measurement cycles.

// To get a TDS value we're going to use a standard calicration curve.
//.      d           a          d                c          b
// y = 80.928 + (6163563000 - 80.928)/(1 + (x/0.4800961)^1.810324)
// Generated by measuring against known values
#define CC_A 6163563000
#define CC_B 1.810324
#define CC_C 0.4800961
#define CC_D 80.928

// Temperature compensation.
/**
 * As ion activity changes drastically with the temperature of the liquid, we have to correct for that. The 
 * temperature correction is a simple "linear correction", typical value for this ALPHA factor is 2%/degC.
 * 
 * Source and more information:
 * https://www.analyticexpert.com/2011/03/temperature-compensation-algorithms-for-conductivity/
 */

// We're going to need to do something about this, because pH is the same. We could either:
// - Directly measure the temperature of the water and compensate
// - Try to estimate water temp based on air temp assuming it's not heated in another way.
// Job for another day.
#define ALPHA 0.02


void setup() {
  // Enable DWT
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  // Reset cycle counter
  DWT->CYCCNT = 0;
  // enable cycle counter
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;

  Serial.begin(9600);
}

void loop() {
  measureEC();
  delay(1000);
}


int dischargeTime = 0;

void fallingEdgeHandler() {
  // Handle the ISR for the measurement pin voltage falling
  dischargeTime = DWT->CYCCNT;
}

bool measureECCycle() {
  // A single cycle of EC measurement. Call n times to oversample for a final EC measurement
  bool timeout = true;

  // Stage 1: charge the cap, positive cycle.
  // CAPPOS: output, high.
  // CAPNEG: output, low.
  // EC: input.
  pinMode(CAPPOS_PIN, OUTPUT);
  pinMode(CAPNEG_PIN, OUTPUT);
  digitalWrite(CAPNEG_PIN, LOW);
  pinMode(EC_PIN, INPUT);
  digitalWrite(CAPPOS_PIN, HIGH);  // Charge the capacitor.
  digitalWrite(EC_PIN, LOW);       // EC pin pull up resistor low.

  // So right now we're charging the capacitor. We want to do this for a known time.
  DWT->CYCCNT = 0;
  while (DWT->CYCCNT < (CHARGE_DELAY * CLOCKSPEED)) {}

  // Stage 2: measure positive discharge cycle by measuring the number of clock cycles it takes
  // for pin CAPPOS to change from HIGH to LOW.
  // CAPPOS: input.
  // CAPNEG: output, low (unchanged).
  // EC: output, low.
  dischargeTime = 0;
  pinMode(CAPPOS_PIN, INPUT);
  digitalWrite(CAPPOS_PIN, LOW);  // pull up resistor low.
  attachInterrupt(digitalPinToInterrupt(CAPPOS_PIN), fallingEdgeHandler, FALLING);
  pinMode(EC_PIN, OUTPUT);
  digitalWrite(EC_PIN, LOW);
  DWT->CYCCNT = 0;
  while (DWT->CYCCNT < (EC_TIMEOUT * CLOCKSPEED)) {
    if (dischargeTime) {
      timeout = false;
      break;
    }
  }
  detachInterrupt(digitalPinToInterrupt(CAPPOS_PIN));
  if (timeout) {
    return -1; // Need to return something here I think to indicate failure.
  }

  // Stage 3: fully discharge the cap, prepare for negative cycle.
  // Necessary to keep total voltage within the allowed range (without these discharge cycles the voltage would jump to about +1.4*Vcc and -0.4*Vcc)
  // CAPPOS: output, low.
  // CAPNEG: output, low (unchanged).
  // EC: input.
  pinMode(CAPPOS_PIN, OUTPUT);
  pinMode(EC_PIN, INPUT);
  DWT->CYCCNT = 0;
  while (DWT->CYCCNT < (DISCHARGE_DELAY * CLOCKSPEED)) {}

  // Stage 4: charge the cap, negative cycle.
  // CAPPOS: output, low (unchanged).
  // CAPNEG: output, high.
  // EC: input (unchanged).
  digitalWrite(CAPNEG_PIN, HIGH);  // CAPNEG HIGH: Charge the cap
  DWT->CYCCNT = 0;
  while (DWT->CYCCNT < (CHARGE_DELAY * CLOCKSPEED)) {}

  // Stage 5: negative discharge cycle, compensation.
  // CAPPOS: input.
  // CAPNEG: output, high (unchanged).
  // EC: output, high.
  attachInterrupt(digitalPinToInterrupt(CAPPOS_PIN), fallingEdgeHandler, FALLING);
  pinMode(CAPPOS_PIN, INPUT);
  digitalWrite(CAPPOS_PIN, LOW);
  pinMode(EC_PIN, OUTPUT);
  digitalWrite(EC_PIN, HIGH);

  DWT->CYCCNT = 0;
  // This seemed weird to me on reading, here's why
  // This is often done in electrical conductivity (EC) measurement techniques to compensate for any charge 
  // that did not discharge during the first cycle, keeping the voltage swing symmetric. Without this delay, 
  // the voltage could drift either positive or negative after a series of measurements because each discharge 
  // cycle might not be long enough to fully discharge the capacitor.
  while (DWT->CYCCNT < (dischargeTime * CLOCKSPEED)) {}
  detachInterrupt(digitalPinToInterrupt(CAPPOS_PIN));

  // Stage 6: fully discharge the cap, prepare for positive cycle.
  // CAPPOS: output, high.
  // CAPNEG: ouput, high (unchanged).
  // EC: input
  pinMode(CAPPOS_PIN, OUTPUT);
  digitalWrite(CAPPOS_PIN, HIGH);
  pinMode(EC_PIN, INPUT);
  digitalWrite(EC_PIN, LOW);
  DWT->CYCCNT = 0;
  while (DWT->CYCCNT < (DISCHARGE_DELAY * CLOCKSPEED)) {}

  return true;
}

void measureEC () {
  unsigned long int avgval = 0; 
  unsigned int validMeasurements = 0;
  // Take 10 readings
  for(int i=0; i<OVERSAMPLING_RATE; i++) {
    if (!measureECCycle()) {
      Serial.println("EC measurement failed, timeout.");
      continue;
    }
    avgval+=dischargeTime;
    validMeasurements++;
    delay(20);  // This seems to stop the values from running away. Probs due to capacitor overcharge.
  }
  if (!validMeasurements) {
    Serial.println("EC failed to measure!");
    return;
  }
  avgval /= OVERSAMPLING_RATE;
  Serial.print("Average discharge time was:");
  Serial.println(avgval);

  float TDS = CC_D + (CC_A - CC_D) / (1 + pow(avgval / CC_C, CC_B));
  Serial.print("Calibrated TDS value was:");
  Serial.println(TDS);
} 
